"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseCommand = exports.getMachineInfo = exports.getBranch = exports.getRunGroup = exports.extractGitSha = exports.NX_CLOUD_NO_TIMEOUTS = exports.VERBOSE_LOGGING = exports.ENCRYPTION_KEY = exports.ACCESS_TOKEN = exports.NUMBER_OF_TRIES = exports.AGENT_RUNNING_IN_DISTRIBUTED_EXECUTION = exports.NX_CLOUD_DISTRIBUTED_EXECUTION_ID = exports.INVOKED_BY_RUNNER = exports.DISTRIBUTED_TASK_EXECUTION_INTERNAL_ERROR_STATUS_CODE = exports.NO_MESSAGES_TIMEOUT = exports.UNLIMITED_TIMEOUT = void 0;
const node_machine_id_1 = require("node-machine-id");
const child_process_1 = require("child_process");
const fs_1 = require("fs");
const path_1 = require("path");
const app_root_1 = require("@nrwl/tao/src/utils/app-root");
const dotenv = require("dotenv");
exports.UNLIMITED_TIMEOUT = 9999999;
exports.NO_MESSAGES_TIMEOUT = 3600000; // 60 minutes
exports.DISTRIBUTED_TASK_EXECUTION_INTERNAL_ERROR_STATUS_CODE = 166;
exports.INVOKED_BY_RUNNER = process.env.NX_INVOKED_BY_RUNNER === 'true';
exports.NX_CLOUD_DISTRIBUTED_EXECUTION_ID = process.env.NX_CLOUD_DISTRIBUTED_EXECUTION_ID;
exports.AGENT_RUNNING_IN_DISTRIBUTED_EXECUTION = !!exports.NX_CLOUD_DISTRIBUTED_EXECUTION_ID;
exports.NUMBER_OF_TRIES = exports.AGENT_RUNNING_IN_DISTRIBUTED_EXECUTION ? 3 : 1;
loadEnvVars();
function extractGitSha() {
    try {
        return child_process_1.execSync(`git rev-parse HEAD`).toString().trim();
    }
    catch (e) {
        return undefined;
    }
}
exports.extractGitSha = extractGitSha;
function parseEnv() {
    try {
        const envContents = fs_1.readFileSync(path_1.join(app_root_1.appRootPath, 'nx-cloud.env'));
        return dotenv.parse(envContents);
    }
    catch (e) {
        return {};
    }
}
function loadEnvVars() {
    const parsed = parseEnv();
    exports.ACCESS_TOKEN =
        process.env.NX_CLOUD_AUTH_TOKEN ||
            process.env.NX_CLOUD_ACCESS_TOKEN ||
            parsed.NX_CLOUD_AUTH_TOKEN;
    exports.ENCRYPTION_KEY =
        process.env.NX_CLOUD_ENCRYPTION_KEY || parsed.NX_CLOUD_ENCRYPTION_KEY;
    exports.VERBOSE_LOGGING =
        process.env.NX_VERBOSE_LOGGING === 'true' ||
            parsed.NX_VERBOSE_LOGGING === 'true';
    exports.NX_CLOUD_NO_TIMEOUTS =
        process.env.NX_CLOUD_NO_TIMEOUTS === 'true' ||
            parsed.NX_CLOUD_NO_TIMEOUTS === 'true';
}
function getRunGroup() {
    if (process.env.NX_RUN_GROUP !== undefined) {
        return process.env.NX_RUN_GROUP;
    }
    if (process.env.CIRCLECI !== undefined) {
        return process.env.CIRCLE_WORKFLOW_ID;
    }
    if (process.env.TRAVIS_BUILD_ID !== undefined) {
        return process.env.TRAVIS_BUILD_ID;
    }
    if (process.env.GITHUB_ACTIONS && process.env.GITHUB_RUN_ID) {
        return process.env.GITHUB_RUN_ID;
    }
    if (process.env.BUILD_BUILDID) {
        return process.env.BUILD_BUILDID;
    }
    return extractGitSha();
}
exports.getRunGroup = getRunGroup;
function getBranch() {
    var _a;
    if (process.env.NX_BRANCH !== undefined) {
        return process.env.NX_BRANCH;
    }
    if (process.env.CIRCLECI !== undefined) {
        if (process.env.CIRCLE_PR_NUMBER !== undefined) {
            return process.env.CIRCLE_PR_NUMBER;
        }
        else if (process.env.CIRCLE_PULL_REQUEST !== undefined) {
            const p = process.env.CIRCLE_PULL_REQUEST.split('/');
            return p[p.length - 1];
        }
        else if (process.env.CIRCLE_BRANCH !== undefined) {
            return process.env.CIRCLE_BRANCH;
        }
    }
    if (process.env.TRAVIS_PULL_REQUEST !== undefined) {
        return process.env.TRAVIS_PULL_REQUEST;
    }
    // refs/pull/78/merge
    if (process.env.GITHUB_ACTIONS) {
        if (process.env.GITHUB_REF) {
            const ref = process.env.GITHUB_REF.match(/refs\/pull\/(\d+)\/merge/);
            if (ref) {
                return ref[1];
            }
        }
        return (_a = process.env.GITHUB_HEAD_REF) !== null && _a !== void 0 ? _a : '';
    }
    // For gitlab merge requests.
    // See: https://docs.gitlab.com/ee/ci/variables/predefined_variables.html
    if (process.env.CI_MERGE_REQUEST_SOURCE_BRANCH_NAME !== undefined) {
        return process.env.CI_MERGE_REQUEST_SOURCE_BRANCH_NAME;
    }
    return undefined;
}
exports.getBranch = getBranch;
function getMachineInfo(options) {
    const os = require('os');
    let machineId = '';
    // TODO: vsavkin remove it
    if (options.canTrackAnalytics) {
        try {
            machineId = node_machine_id_1.machineIdSync();
        }
        catch (_a) { }
    }
    return {
        machineId,
        platform: os.platform(),
        version: os.version ? os.version() : '',
        cpuCores: os.cpus().length,
    };
}
exports.getMachineInfo = getMachineInfo;
function parseCommand() {
    var _a;
    const env = (_a = process.env.NX_CLOUD_ENV_NAME) !== null && _a !== void 0 ? _a : undefined;
    const res = `nx ${process.argv.slice(2).join(' ')}`;
    return env ? `${env} ${res}` : res;
}
exports.parseCommand = parseCommand;
//# sourceMappingURL=environment.js.map