"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileStorage = void 0;
const output_1 = require("@nrwl/workspace/src/utilities/output");
const path = require("path");
const environment_1 = require("../../utilities/environment");
const axios_1 = require("../../utilities/axios");
const fs_1 = require("fs");
const axios = require('axios');
const tar = require('tar');
class FileStorage {
    constructor(encryption, numberOfTries) {
        this.encryption = encryption;
        this.numberOfTries = numberOfTries;
    }
    retrieve(hash, url, cacheDirectory) {
        return __awaiter(this, void 0, void 0, function* () {
            if (environment_1.VERBOSE_LOGGING) {
                output_1.output.note({
                    title: `Nx Cloud: Downloading ${hash}`,
                    bodyLines: [`RETRIEVAL URL: ${url}`],
                });
            }
            const tgz = this.createFileName(hash, cacheDirectory);
            yield this.downloadFile(url, tgz);
            this.createCommitFile(hash, cacheDirectory);
            if (environment_1.VERBOSE_LOGGING) {
                output_1.output.note({ title: `Nx Cloud: Downloaded ${hash}` });
            }
        });
    }
    store(hash, url, cacheDirectory) {
        return __awaiter(this, void 0, void 0, function* () {
            if (environment_1.VERBOSE_LOGGING) {
                output_1.output.note({
                    title: `Nx Cloud: Storing ${hash}`,
                    bodyLines: [`STORAGE URL: ${url}`],
                });
            }
            const tgz = yield this.createFile(hash, cacheDirectory);
            yield this.uploadFile(url, tgz);
            if (environment_1.VERBOSE_LOGGING) {
                output_1.output.note({ title: `Nx Cloud: Stored ${hash}` });
            }
        });
    }
    createFileName(hash, cacheDirectory) {
        return path.join(cacheDirectory, `${hash}.tar.gz`);
    }
    downloadFile(url, tgz) {
        return __awaiter(this, void 0, void 0, function* () {
            const resp = yield axios_1.axiosMultipleTries(() => axios(url, {
                method: 'GET',
                responseType: 'stream',
                maxContentLength: 1000 * 1000 * 300,
                maxBodyLength: 1000 * 1000 * 300,
                timeout: environment_1.NX_CLOUD_NO_TIMEOUTS ? environment_1.UNLIMITED_TIMEOUT : 60000,
            }), this.numberOfTries);
            if (this.encryption.hasEncryption()) {
                yield new Promise((res) => {
                    const f = resp.data.pipe(fs_1.createWriteStream(tgz));
                    f.on('close', () => res(null));
                });
                this.encryption.decryptFile(tgz);
                const q = fs_1.createReadStream(tgz).pipe(tar.x({
                    cwd: path.dirname(tgz),
                }));
                return new Promise((res) => {
                    q.on('close', () => res(null));
                });
            }
            else {
                const q = resp.data.pipe(tar.x({
                    cwd: path.dirname(tgz),
                }));
                return new Promise((res) => {
                    q.on('close', () => res(null));
                });
            }
        });
    }
    createCommitFile(hash, cacheDirectory) {
        fs_1.writeFileSync(path.join(cacheDirectory, `${hash}.commit`), 'true');
    }
    createFile(hash, cacheDirectory) {
        return __awaiter(this, void 0, void 0, function* () {
            const tgz = this.createFileName(hash, cacheDirectory);
            yield tar.c({
                gzip: true,
                file: tgz,
                cwd: cacheDirectory,
            }, [hash]);
            if (this.encryption.hasEncryption()) {
                this.encryption.encryptFile(tgz);
            }
            return tgz;
        });
    }
    uploadFile(url, tgz) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield axios_1.axiosMultipleTries(() => axios(url, {
                method: 'PUT',
                data: fs_1.readFileSync(tgz),
                headers: {
                    'Content-Type': 'application/octet-stream',
                    'x-ms-blob-type': 'BlockBlob',
                },
                maxContentLength: 1000 * 1000 * 300,
                maxBodyLength: 1000 * 1000 * 300,
                timeout: environment_1.NX_CLOUD_NO_TIMEOUTS ? environment_1.UNLIMITED_TIMEOUT : 120000,
            }), this.numberOfTries);
        });
    }
}
exports.FileStorage = FileStorage;
//# sourceMappingURL=file-storage.js.map